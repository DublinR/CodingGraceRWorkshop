


%---------------------------------------------------------------------------Probability Distributions ----%

chapter{Probability Distributions}
<p>
### {Generating a set of random numbers}

begin{myindentpar}{1cm}
 <code>
rnorm(10)
</code>
end{myindentpar}

<p>
### {The Poisson Distribution}
<p>
### {The Binomial Distribution}
<p>
### {Using probability distributions for simulations}
<p>
### {Probability Distributions}
<p>
#### {Generate random numbers }

%----------------------------------------------------------------------------Graphical Methods--%

chapter{Graphical methods}

<p>
### {Scatterplots}
%begin{figure}
  % Requires usepackage{graphicx}
  % includegraphics[scale=0.40]{MTCARSmpgwt.png}
  % caption{Scatterplot}label{mpgwt}
% end{figure}


<p>
### {Adding titles, lines, points to plots}


 <code>
library(MASS)
# Colour points and choose plotting symbols according to a levels of a factor
plot(Cars93$Weight, Cars93$EngineSize, col=as.numeric(Cars93$Type),
pch=as.numeric(Cars93$Type))

# Adds x and y axes labels and a title.
plot(Cars93$Weight, Cars93$EngineSize, ylab="Engine Size",
xlab="Weight", main="My plot")
# Add lines to the plot.
lines(x=c(min(Cars93$Weight), max(Cars93$Weight)), y=c(min(Cars93$EngineSize),
max(Cars93$EngineSize)), lwd=4, lty=3, col="green")
abline(h=3, lty=2)
abline(v=1999, lty=4)
# Add points to the plot.
</code>


chapter{Programming}

<p>
### {Writing Functions}

A simple function can be constructed as follows:

<code>
function_name <- function(arg1, arg2, ...){
commands
output
}
</code>

You decide on the name of the function. The function command shows R that you are writing a function. Inside the parenthesis you outline the input objects required and decide what to call them. The commands occur inside the { }.

The name of whatever output you want goes at the end of the function. Comments lines (usually a description of what the function does is placed at the beginning) are denoted by "#".

<code>sf1 <- function(x){
x^2
}
</code>

This function is called sf1. It has one argument, called x.
Whatever value is inputted for x will be squared and the result outputted to the screen. This function must be loaded into texttt{R} and can then be called. We can call the function using:
<code>
sf1(x = 3)
#sf1(3)
[1] 9
To store the result into a variable x.sq
x.sq <- sf1(x = 3)
x.sq <- sf1(3)
> x.sq
[1] 9
</code>
Example
<code>
sf2 <- function(a1, a2, a3){
x <- sqrt(a1^2 + a2^2 + a3^2)
return(x)
}
</code>

This function is called sf2 with 3 arguments. The values inputted for a1, a2, a3 will be squared, summed and the square root of the sum calculated and stored in x. (There will be no output to the screen as in the last example.)
The return command specifies what the function returns, here the value of x. We will not be able to view the result of the function unless we store it.
<code>sf2(a1=2, a2=3, a3=4)
sf2(2, 3, 4) # Can't see result.
res <- sf2(a1=2, a2=3, a3=4)
res <- sf2(2, 3, 4) # Need to use this.
res
[1] 5.385165
</code>
We can also give some/all arguments default values.
<code>mypower <- function(x, pow=2){
x^pow
}
</code>
If a value for the argument pow is not specified in the function call,
a value of 2 is used.
<code>mypower(4)
[1] 16
</code>
If a value for "pow" is specified, that value is used.
<code>
mypower(4, 3)
[1] 64
mypower(pow=5, x=2)
[1] 32
</code>








%----------------------------------------------------%


 <code>
> code here
 </code>


 <code>
> code here
 </code>



%---------------------------------------------------%

#### {slide234}
The TS are <equation here>  
The p-values for both of these tests are 0 and so there is enough evidence to reject $H_0$ and conclude that both 0 and 1 are not 0, i.e. there is a significant linear relationship between x and y. 
Also given are the $R^2$ and $R^2$ adjusted values. Here $R^2 = SSR/SST = 0.8813$ and so $88.13%$ of the variation in y is being explained by x. 
The final line gives the result of using the ANOVA table to assess the model t.

%----------------------------------------------------%


#### {slide235}

In SLR, the ANOVA table tests <EQN>The TS is the F value and the critical value and p-values are found
in the F tables with (p - 1) and (n - p) degrees of freedom.

This output gives the p-value = 0, therefore there is enough evidence to reject H0 and conclude that there is a signicant linear relationship between y and x. The full ANOVA table can be accessed using :

<TABLE HERE>




#### {slide236}
Once the model has been tted, must then check the residuals.
The residuals should be independent and normally distributed with
mean of 0 and constant variance.
A Q-Q plot checks the assumption of normality (can also use a
histogram as in MINITAB) while a, plot of the residuals versus fitted values gives an indication as to whether the assumption of constant variance holds.

<HISTOGRAM>


%----------------------------------------------------%

#### {slidename}

 <code>
> xbar <- 83
> sigma <- 12
> n <- 5
> sem <- sigma/sqrt(n)
> sem
[1] 5.366563
> xbar + semqnorm(0.025)
[1] 72.48173
> xbar + semqnorm(0.975)
[1] 93.51827
 </code>



#### {Testing the slope (II)}

You can compute a
t test for that hypothesis simply by dividing the estimate by its standard
error
begin{equation}
t = frac{hat{beta}}{S.E.(hat{beta})}
end{equation}
which follows a t distribution on n - 2 degrees of freedom if the true $beta$ is
zero.


%----------------------------------------------------%

The standard $chi^{2}$ test  in chisq.test works with data in matrix form, like fisher.test does.
For a 2 by 2 table, the test is exactly equivalent to prop.test.



 <code>
> chisq.test(lewitt.machin)
</code>


%----------------------------------------------------%


#### {Chi-squared Test}

A $chi^2$ test is carried out on tabular data containing counts, e.g. the
number of animals that died, the number of days of rain, the
number of stocks that grew in value, etc.

Usually have two qualitative variables, each with a number of
levels, and want to determine if there is a relationship between the
two variables, e.g. hair colour and eye colour, social status and
crime rates, house price and house size, gender and left/right
handedness.

The data are presented in a contingency table:
right-handed left-handed TOTAL

begin{tabular}{|c|c|c|c|}
  hline
  % after : hline or cline{col1-col2} cline{col3-col4} ...
  & right-handed &left-handed & TOTALhline
  Male & 43 & 9 & 52 
  Female & 44 & 4 & 48 
  TOTAL & 87 & 13 & 100 
  hline
end{tabular}


The hypothesis to be tested is
$H0 :$There is no relationship between gender and left/right-handedness
$H1 :$There is a relationship between gender and left/right-handedness
 The values that we collect from our sample are called the observed
(O) frequencies (counts). Now need to calculate the expected (E)
frequencies, i.e. the values we would expect to see in the table, if
H0 was true.






%------------------------------------------------------%

#### {Two Sample Tests}


All of the previous hypothesis tests and confidence intervals can be
extended to the two-sample case.

The same assumptions apply, i.e. data are normally distributed in
each population and we may want to test if the mean in one
population is the same as the mean in the other population, etc.

Normality can be checked using histograms, boxplots and Q-Q
plots as before. The Anderson-Darling test can be used on
each group of data also.


%------------------------------------------------------%

#### {Implementation}

This can be carried out in R by hand:

 <code>
>obs.vals <- matrix(c(43,9,44,4), nrow=2, byrow=T)
>row.tots <- apply(obs.vals, 1, sum)
>col.tots <- apply(obs.vals, 2, sum)
>exp.vals <- row.tots%o%col.tots/sum(obs.vals)
>TS <- sum((obs.vals-exp.vals)^2/exp.vals)
>TS
>[1] 1.777415
 </code>


%------------------------------------------------------%




chapter { R Graphics}
<p>
###  Enhancing your scatter plots
<p>
#### {Adding lines}
Previously we have used scatter plots to plot bivariate data. They were constructed using the plot() command.
Recall that we can use the arguments texttt{xlim} and texttt{ylim} to control the vertical and horizontal range of the plots, by specifying a two element vector (min and max) for each.

Using the texttt{abline()} command, we can add lines to our scatter plots. We specify the argument according to the type of line required. A demonstration of three types of line is provided below.
Additionally we change the colour of the added lines, by specifying a colour in the texttt{col} argument. We can also change the line type to one of four possible types, using the texttt{lty} argument.

The line types are follows

      	texttt{lty =1}   Normal full line (default)
      	texttt{lty =2}   Dashed line
      	texttt{lty =3}   Dotted line
      	texttt{lty =4}   Dash-dot line

 <code>
x=rnorm(10)
y=rnorm(10)
plot(x,y)
plot(x,y,xlim=c(-4,4),ylim=c(-4,4))
abline(v =0 , lty =2 )    # add a vertical dotted line (here the y-axis) to the plot
abline(h=0  ,lty =3)    # add a horizontal dotted line (here the x-axis) to the plot
abline(a=0,b=1,col="green") # add a line to your plot with intercept "a" and slope "b"
 </code>

<p>
#### {Changing your plot character}

To change the plot character (the symbol for each covariate, we supply an additional argument to the plot() function.  This argument is formulated as pch=n where n is some number.
Additionally we change the colour of the characters, by specifying a colour in the col argument.
 <code>
plot(x,y,pch=15,col="red")		#Square plot symbols
plot(x,y,pch=16,col="green")		#Orb plot symbols
plot(x,y,pch=17,col="mauve")		#Triangular plot symbols
plot(x,y,pch=36	,col="amber")		#Dollar sign plot symbols
</code>
Recall that we can add new variates to an existing scatterplot using the points() function. Remember to set the vertical and horizontal limits accordingly.
 <code>
y1 = rnorm(10); y2 = rnorm(10)
plot(x,y1, pch=8,col="purple" ,xlim=c(-5,5),ylim=c(-5,5))
points(x,y2,pch=12,col="green")
</code>
<p>
#### {Adding the regression model line}

The texttt{abline()} function can be used to add a regression model line  by supplying as an argument the texttt{coef()} values for intercept and slope estimates .These estimates can be inputted directly by using both functions in conjunction.

 <code>
Fit1 =lm(y1~x);  coef(Fit1)
abline(coef(Fit1))	
</code>

<p>
#### {Adding a title }

It is good practice to label your scatterplots properly. You can specify the following argument

      	main="Scatterplot Example", 	This provides the plot with a title
      	sub="Subtitle",   This adds a subtitle
      	xlab="X variable ",				This command labels the x axis 
  ylab="y variable ",				This command labels the y-axis

We can also add text to each margin, using the texttt{mtext()} command.  
We simply require the number of the side. (1 = bottom, 2=left,3=top,4=right). 
We can change the colour using the col argument.
 <code>
plot(x,y,main="Scatterplot Example",   sub="subtitle",    xlab="X variable ", ylab="y variable ")	
mtext("Enhanced Scatterplot", side=4,col="red ")
</code>
Alternatively , we can also use the command title() to add a title to an existing scatterplot.
 <code>
title(main="Scatterplot Example)	
</code>
