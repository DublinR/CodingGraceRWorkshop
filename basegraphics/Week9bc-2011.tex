\documentclass[pdf,default,slideColor,colorBG]{prosper}



% define a new font called goodfont
\def\goodfont{\usefont{T1}{pcr}{b}{n}\fontsize{36pt}{40pt}\selectfont\green}
\renewcommand{\familydefault}{\rmdefault}
\renewcommand{\rmdefault}{cmr}
\parindent 0pt
\parskip 5pt


\begin{document}


\begin{slide}{Assessments}
\begin{itemize}
\item This outcome of this project is to enhance understanding of numerical computation software, and it's
role in the professional or academic world.

\item If your software or R packages are aimed at a certain type of analysis, include a description of your analysis. \item Mention how this methodology would be used in
the professional world.
\end{itemize}
\end{slide}
\begin{slide}{Assessments}
\begin{itemize}

\item Describe how an analyst would go about acquiring a piece of software.

\item If relevant, describe how one would become trained in the use of the software.
\item The document should be submitted in Latex, but to accompanying graphics may be submitted on Microsoft Word.
\item (i.e. use the new line twice to create a blank page).
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------%
\begin{slide}{Week 9 (Thursday)}

Today's Class

\begin{itemize}
    \item The scan command.
    \item Factors.
    \item Data frames.
    \item Attributes.
    \item Making subsets.
    \item Lists.
    \item Missing values.
    \item Exercises
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------%
\begin{slide}{Some more vector functions}
\begin{itemize}
\item cumsum()  - computes the cumulative sums for a vector
\item cumprod() - computes the cumulative products for a vector
\item diff()  - computes lagged  differences (default difference is 1)

\begin{verbatim}
> s <- c(1,1,3,4,7,11)
> cumsum(s)
[1] 1 2 5 9 16 27
>
> diff(s) # 1-1, 3-1, 4-3, 7-4, 11-7
[1] 0 2 1 3 4
>
> diff(s, lag = 2) # 3-1, 4-1, 7-3, 11-4
[1] 2 3 4 7
>
\end{verbatim}
\end{itemize}
\end{slide}



%--------------------------------------------------------------------------------%

\begin{slide}{The scan function}
\begin{itemize}
\item We can use the function  ``scan()" when typing in data.
\item It stops adding data when you enter a blank row.
\item for more information type ``?scan" , but the basic usage is simple.

\begin{verbatim}
> y=scan()
1: 4 5 6 7 8 9
7:
Read 6 items
> y
[1] 4 5 6 7 8 9
\end{verbatim}
\end{itemize}
\end{slide}


%------------------------------------------------------------------------------------------------------%

\begin{slide}{Datasets Included with R}
\begin{itemize}
\item R contains many datasets that are built-in to the software. \item These datasets are stored as data
frames. \item To see the list of datasets, type
\begin{verbatim}
> data()
\end{verbatim}
\item Additionally, we will be using datasets embedded on the MASS package.
\item To access those data sets, simply type
\begin{verbatim}
> library(MASS)
> data()
\end{verbatim}
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------%

\begin{slide}{Datasets Included with R}
\begin{itemize}
\item A window will open and the available datasets are listed (many others are accessible from
external user-written packages, however). \item To open the dataset called trees, simply type

\begin{verbatim}
> data(trees)
\end{verbatim}

\item After doing so, the data frame trees is now in your workspace. \item  To learn more about this (or
any other included dataset), type help(trees).
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------%

\begin{slide}{Categorical Data}
\begin{itemize}
\item 
There is a distinction between types of data in statistics and R knows about some of these differences. In particular,
initially, data can be of three basic types: categorical, discrete numeric and continuous numeric. \item Methods for viewing
and summarizing the data depend on the type, and so we need to be aware of how each is handled and what we can
do with it.
\end{itemize}
\end{slide}

%--------------------------------------------------------------------------------%

\begin{slide}{Categorical Data (contd)}
\begin{itemize}
\item Categorical data may be recorded using character vectors.
\item For example, a survey asks people if they smoke or not. \item The results may be recorded as follows.

\begin{verbatim}
>x=c("Yes","No","No","Yes","Yes","No","No","Yes")
\end{verbatim}
\end{itemize}
\end{slide}



%------------------------------------------------------------------------------------------------------%

\begin{slide}{Categorical Data (contd)}
\begin{itemize}
\item To summarize this data. we can use the ``table()" command

\begin{verbatim}
> table(x)
x
 No Yes
  4   4
\end{verbatim}

\item The table command simply adds up the frequency of each unique value of the data.
\end{itemize}
\end{slide}


\begin{slide}{Factors}
\begin{itemize}
\item  Categorical data is often used to classify data into various levels or factors.
\item For example, the smoking data could be part of a broader survey on student health issues.
\item In such case, gender and alcohol consumption would be other probable factors.
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------%
\begin{slide}{Factors}
\begin{itemize}
\item A factor is a special type of vector used to represent
categorical data, e.g. gender, social class, etc. \item Stored
internally as a numeric vector with values 1, 2, ... k, where k is
the number of levels. \item Can have either ordered and unordered
factors. \item A factor with k levels is stored internally
consisting of 2 items; a vector of k integers and a character
vector containing strings describing what the k levels are.
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------%
\begin{slide}{Factors: Example}
\begin{itemize}
\item Consider a survey that has data on 200 females and 300
males. \item If the first 200 values are from females and the next 300
values are from males, one way of representing this is to create a
vector
\begin{verbatim}
> gender <- c(rep("female", 200),
  rep("male", 300))
\end{verbatim}
\item 
To change this into a factor
\begin{verbatim}
> gender <- factor(gender)
\end{verbatim}
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------%
\begin{slide}{Factors: Levels}
\begin{itemize} \item The factor gender is stored internally as '1' for `female'
and `2' for male. \item Each category, i.e. female and male, is
called a level of the factor.  \item To determine the levels of a
factor the function levels() can be used:

\begin{verbatim}
> levels(gender)
[1] "female" "male"
\end{verbatim}
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------%

\begin{slide}{Data Frames : Introduction}
A data frame can be thought of
\begin{itemize}
\item as a data matrix or data set \item is a generalization of a
matrix \item is a data structure of vectors and/or factors of the
same length \item  The frame has a unique set of row names. \item Data in
the same position across columns come from the same subject. \item
Most data sets are in the form of a data frame.
\end{itemize}

\end{slide}
%------------------------------------------------------------------------------------------------------%

\begin{slide}{Data Frames: Creating a data frame}
\begin{itemize}
\item Data frames can be constructed using component vectors.
\item 
We can create data frames from variables using the data.frame()
command:
\begin{verbatim}
>mean_weight=c(71.5,72.1,73.7,74.3,75.2,74.7)
>
>Gender=c("M", "M", "F", "F", "M", "M")
>
> d <- data.frame(mean_weight,Gender)
\end{verbatim}
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------%


\begin{slide}{Data Frames: Indexing}

\begin{itemize}
\item The $n$th row of a data frame can be accessed as follows:
\begin{verbatim}
> framename[n,]
\end{verbatim}
leaving the column argument empty. \item Similarly the $m$th
column of a data frame can be accessed as follows:
\begin{verbatim}
> framename[,m]
\end{verbatim}
this time leaving the row argument empty.

\item A particular value can be accessed by specifying the row and
column numbers together.
\begin{verbatim}
> framename[n,m]
\end{verbatim}
\end{itemize}

\end{slide}



%------------------------------------------------------------------------------------------------------%
\begin{slide}{Data Frames: Attributes}

All objects (except simple values) can have one or more attributes attached to them.
These commands can be used to determine particular attributes.
\begin{itemize}
    \item names() - can find the labels of the individual columns.
    \item dim() - can find the dimensions of a data object.
\end{itemize}

\end{slide}

%------------------------------------------------------------------------------------------------------%
\begin{slide}{Data Frames: Assessing Data}
An assessment of how the data frame is structured can be made by visual inspection.
If a data set is called, it will be printed on screen in its entirety.
This is often hard to read and very unhelpful. \\ Often a visual inspection of the first few rows will suffice.
To access the first six rows of a data frame, use the head() command.
\begin{verbatim}
> head(ChickWeight)
  weight Time Chick Diet
1     42    0     1    1
2     51    2     1    1
3     59    4     1    1
4     64    6     1    1
5     76    8     1    1
6     93   10     1    1
\end{verbatim}
\end{slide}




%------------------------------------------------------------------------------------------------------%
\begin{slide}{Data Frames: Accessing columns}
\begin{itemize}
\item The names of columns can be found by using the names()
command.
\begin{verbatim}
> names(ChickWeight)
[1] "weight" "Time"   "Chick"  "Diet"
\end{verbatim}

\item Individual columns can be accessed using the '\$' operator.
\begin{verbatim}
>ChickWeight$weight
\end{verbatim}


\item The columns can now be studied in the same ways as basic
vectors.
\begin{verbatim}
> mean(ChickWeight$weight)
[1] 121.8183
\end{verbatim}
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------------------------%
\begin{slide}{Data Frames: Dimensions}

The dimensions of a data frame can be found using the dim()
command.
\begin{verbatim}
> dim(ChickWeight)
[1] 578   4
\end{verbatim}
Alternatively we can use the nrow() and ncol() commands, which
return the number of rows and columns of a specified data frame
respectively.
\begin{verbatim}
>  nrow(ChickWeight)
[1] 578
>  ncol(ChickWeight)
[1] 4
\end{verbatim}
\end{slide}
%------------------------------------------------------------------------------------------------------------------------%
\begin{slide}{Subsetting data sets}
\begin{itemize}
\item Often, we would wish to make a subset of a larger data
set.We would use logical and relational operators to do so. We can
pick all rows which fulfil the criteria.


\begin{verbatim}
> ChickWeight[ChickWeight$Chick=='1',]
> ChickWeight[ChickWeight$weight>50,]
\end{verbatim}
\item It doesn't make sense to subset by columns. Therefore, the
following code wouldn't work.

\begin{verbatim}
> ChickWeight[, ChickWeight$Chick=='1']
\end{verbatim}
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------------------------%
\begin{slide}{Lists}
\begin{itemize}
\item An R list is an object consisting of an ordered collection of objects known as its components.
\item A list could consist of any combination of numeric vector, a logical value,
a matrix, a complex vector, a character array, a function, and so on.
\item
Here is a simple example of how to make a list:
\begin{verbatim}
> Lst <- list(name="Fred", wife="Mary",
        no.children=3, child.ages=c(4,7,9))
\end{verbatim}
\end{itemize}

\end{slide}



%------------------------------------------------------------------------------------------------------------------------%
\begin{slide}{Lists: Components}
\begin{itemize}
\item Components are always numbered and may always be referred to
as such. \item Thus if Lst is the name of a list with four
components, these may be individually referred to as Lst[[1]],
Lst[[2]], Lst[[3]] and Lst[[4]]. \item If Lst[[4]] is a vector,
then Lst[[4]][1] is its first entry. \item Components of lists may
also be named and can be accessed with an expression of the form
\begin{verbatim}
     > name$component_name
\end{verbatim}
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------------------------%
\begin{slide}{Lists: Names and Indices}

In our simple example:
\begin{itemize}
\item Lst\$name  is the same as  Lst[[1]] and is the string
"Fred",

\item Lst\$wife  is the same as  Lst[[2]]
 and is the string "Mary",

\item Lst\$child.ages[1]is the same as Lst[[4]][1] and is the
number 4.
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------%
\begin{slide}{Missing Data}
\begin{itemize}
\item In some cases the components of a vector may not be
completely known. When an element or value is 'not available' or a
'missing value' in the statistical sense, a place within a vector
may be reserved for it by assigning it the special value NA.

\item In general any operation on an NA becomes an NA.
\item The motivation for this rule is simply that if the specification of an operation
is incomplete, the result cannot be known and hence is not available.
\end{itemize}
\end{slide}

%------------------------------------------------------------------------------------------------------%
\begin{slide}{Missing Data (contd)}
\begin{itemize}
\item The command is.na() can be used to determine whether there
are any missing values in a data set, by means of a logical
vector.

\begin{verbatim}
> is.na(x)
[1] FALSE FALSE FALSE FALSE FALSE
\end{verbatim}
\end{itemize}
\end{slide}
%------------------------------------------------------------------------------------------------------------------------%
\begin{slide}{Exercise}
We are going to analyse the Chick weight data.
In your report, report the following pieces of information.
\\
For this exercise, the necessary summary statistics are: the mean, median, variance, maximum and minimum.

\begin{itemize}
    \item A brief discussion of the data set.
    \item The names and dimensions of the data set.
    \item The levels of the Diet factor.
    \item The summary statistics of weights on day `2'.
    \item The summary statistics the weights on day`14'.
\end{itemize}

\end{slide}
\end{document}
